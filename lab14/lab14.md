# Отчет по лабораторной работе №14

----

# Тема:
## Средства, применяемые при разработке программного обеспечения в ОС типа UNIX/Linux.

----

## Российский Университет Дружбы Народов

### Факультет Физико-Математических и Естественных Наук

*Дисциплина: Операционные системы*

Студент: Мухамедияр Адиль

Группа: НКНбд-01-20

Москва, 2021г.

----

### Цель работы

Приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

----

### Введение

Процесс разработки программного обеспечения обычно разделяется на следующие этапы:
* планирование, включающее сбор и анализ требований к функционалу и другим характеристикам разрабатываемого приложения;
* проектирование, включающее в себя разработку базовых алгоритмов и спецификаций, определение языка программирования;
* непосредственная разработка приложения:
* кодирование — по сути создание исходного текста программы (возможно в нескольких вариантах);
* анализ разработанного кода;
* сборка, компиляция и разработка исполняемого модуля;
* тестирование и отладка, сохранение произведённых изменений;
* документирование.
Для создания исходного текста программы разработчик может воспользоваться любым удобным для него редактором текста: vi, vim, mceditor, emacs, geany и др. После завершения написания исходного кода программы (возможно состоящей из нескольких файлов), необходимо её скомпилировать и получить исполняемый модуль.

----

### Ход работы:

1. В домашнем каталоге создал подкаталог *~/work/os/lab_prog*.

![1_1.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/1_1.PNG?raw=true)

2. Создал в нём файлы: calculate.h, calculate.c, main.c. Это примитивнейший калькулятор, способный складывать, вычитать, умножать, делить, возводить число в степень, вычислять квадратный корень, вычислять sin, cos, tan.

![2_1.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/2_1.PNG?raw=true)

* Основной файл main.c, реализующий интерфейс пользователя к калькулятору:

![2_2.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/2_2.PNG?raw=true)

* Интерфейсный файл calculate.h, описывающий формат вызова функции калькулятора:

![2_3.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/2_3.PNG?raw=true)

* Реализация функций калькулятора в файле calculate.c:

![2_4.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/2_4.PNG?raw=true)

* При запуске он запрашивает первое число, операцию, второе число. После этого программа выводит результат и останавливается.

![2_5.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/2_5.PNG?raw=true)

* Калькулятор способен складывать, вычитать, умножать, делить, возводить число в степень, вычислять квадратный корень, вычислять sin, cos, tan.

![2_6.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/2_6.PNG?raw=true)

3. Выполнил компиляцию программы посредством gcc.

![3_1.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/3_1.PNG?raw=true)

4. Исправил синтаксические ошибки.

5. Создал *makefile*. В содержании файла указаны флаги компиляции, тип компилятора и файлы, которые должен собрать сборщик.

![5.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/5.PNG?raw=true)

6. С помощью *gdb* выполнил отладку программы. Но с начало исправил *makefile*.

![6_0.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_0.PNG?raw=true)

* После ввел следующую команду.

![6_0_0.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_0_0.PNG?raw=true)

* Запустил отладчик GDB, загрузив в него программу для отладки: gdb ./calcul.

![6_1.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_1.PNG?raw=true)

* Для запуска программы внутри отладчика ввел команду *run*.

![6_2.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_2.PNG?raw=true)

* Для постраничного (по 9 строк) просмотра исходного кода использовал команду *list*.

![6_3.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_3.PNG?raw=true)

* Для просмотра строк с 12 по 15 основного файла использовал *list* с параметрами: *list 12,15*.

![6_4.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_4.PNG?raw=true)

* Для просмотра определённых строк не основного файла использовал *list* с параметрами: *list calculate.c:20,29*.

![6_5.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_5.PNG?raw=true)

* Установил точку останова в файле *calculate.c* на строке номер 21: 
>list calculate.c:20,27
break 21

![6_6.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_6.PNG?raw=true)

* Вывел информацию об имеющихся в проекте точка останова: *info breakpoints*

![6_7.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_7.PNG?raw=true)

* Запустил программу внутри отладчика. Отладчик выдал следующую информацию, а команда *backtrace* показала весь стек вызываемых функций от начала программы.

Посмотрел, чему равно на этом этапе значение переменной *Numeral*, введя:
>print Numeral

Сравнил с результатом вывода на экран после использования команды:
>display Numeral

![6_8.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_8.PNG?raw=true)

* Убрал точки останова:
>info breakpoints
delete 1

![6_11.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/6_11.PNG?raw=true)

7. С помощью утилиты *splint* попробовал проанализировать коды файлов **calculate.c**. 

![7_1.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/7_1.PNG?raw=true)

* С помощью утилиты *splint* попробовал проанализировать коды файлов **main.c**.

![7_2.img](https://github.com/adil-cpu/OS_/blob/main/lab14/img/7_2.PNG?raw=true)

----

### Вывод

Приобрел простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования C калькулятора с простейшими функциями.

----

### Библиография

[Основы операционной системы UNIX](https://www.opennet.ru/docs/RUS/unix_basic/)

[Программы UNIX-подобных операционных систем](https://dic.academic.ru/dic.nsf/ruwiki/9511)

----

## Ответы на контрольные вопросы:

1. Информацию об этих программах можно получить с помощью функций info и man.
2. Unix поддерживает следующие основные этапы разработки приложений:
* создание исходного кода программы; - представляется в виде файла
* сохранение различных вариантов исходного текста;
* анализ исходного текста; необходимо отслеживать изменения исходного кода, а также при работе более двух программистов над проектом программы нужно, чтобы они не делали изменений кода в одно время.
* компиляция исходного текста и построение исполняемого модуля;
* тестирование и отладка; - проверка кода на наличие ошибок
* сохранение всех изменений, выполняемых при тестировании и отладке.
3. Использование суффикса ".с" для имени файла с программой на языке Си отражает удобное и полезное соглашение, принятое в ОС UNIX. Для любого имени входного файла суффикс определяет какая компиляция требуется. Суффиксы и префиксы указывают тип объекта. Одно из полезных свойств компилятора Си — его способность по суффиксам определять типы файлов. По суффиксу .c компилятор распознает, что файл abcd.c должен компилироваться, а по суффиксу .o, что файл abcd.о является объектным модулем и для получения исполняемой программы необходимо выполнить редактирование связей. Простейший пример командной строки для компиляции программы abcd.c и построения исполняемого модуля abcd имеет вид: gcc -o abcd abcd.c. Некоторые проекты предпочитают показывать префиксы в начале текста изменений для старых (old) и новых (new) файлов. Опция – prefix может быть использована для установки такого префикса. Плюс к этому команда bzr diff -p1 выводит префиксы в форме которая подходит для команды patch -p1.
4. Основное назначение компилятора с языка Си заключается в компиляции всей программы в целом и получении исполняемого модуля.
5. При разработке большой программы, состоящей из нескольких исходных файлов заголовков, приходится постоянно следить за файлами, которые требуют перекомпиляции после внесения изменений. Программа make освобождает пользователя от такой рутинной работы и служит для документирования взаимосвязей между файлами. Описание взаимосвязей и соответствующих действий хранится в так называемом make-файле, который по умолчанию имеет имя makefile или Makefile.
6. В общем случае make-файл содержит последовательность записей (строк), определяющих зависимости между файлами. Первая строка записи представляет собой список целевых (зависимых) файлов, разделенных пробелами, за которыми следует двоеточие и список файлов, от которых зависят целевые. Текст, следующий за точкой с запятой, и все последующие строки, начинающиеся с литеры табуляции, являются командами OC UNIX, которые необходимо выполнить для обновления целевого файла. Таким образом, спецификация взаимосвязей имеет формат: target1 [ target2...]: [:] [dependment1...] [(tab)commands] [#commentary] [(tab)commands] [#commentary], где # — специфицирует начало комментария, так как содержимое строки, начиная с # и до конца строки, не будет обрабатываться командой make; : — последовательность команд ОС UNIX должна содержаться в одной строке make-файла (файла описаний), есть возможность переноса команд (\), но она считается как одна строка; :: — последовательность команд ОС UNIX может содержаться в нескольких последовательных строках файла описаний. 
7. Пошаговая отладка программ заключается в том, что выполняет один оператор программы и, затем контролируются те переменные, на которые должен был воздействовать данный оператор. Если в программе имеются уже отлаженные подпрограммы, то подпрограмму можно рассматривать, как один оператор программы и воспользоваться вторым способом отладки программ. Если в программе существует достаточно большой участок программы, уже отлаженный ранее, то его можно выполнить, не контролируя переменные, на которые он воздействует. Использование точек останова позволяет пропускать уже отлаженную часть программы. Точка останова устанавливается в местах, где необходимо проверить содержимое переменных или просто проконтролировать, передаётся ли управление данному оператору.
8. backtrace - вывод на экран пути к текущей точке останова (по сути вывод названий всех функций)
break - установить точку останова (в качестве параметра может
быть указан номер строки или название функции)
clear - удалить все точки останова в функции
continue - продолжить выполнение программы
delete - удалить точку останова
display - добавить выражение в список выражений, значения которых отображаются при достижении точки останова программы
finish - выполнить программу до момента выхода из функции
info breakpoints - вывести на экран список используемых точек останова
info watchpoints - вывести на экран список используемых контрольных выражений
list - вывести на экран исходный код (в качестве параметра может быть указано название файла и через двоеточие номера начальной и конечной строк)
next - выполнить программу пошагово, но без выполнения вызываемых в программе функций
print - вывести значение указываемого в качестве параметра выражения
run - запуск программы на выполнение
set - установить новое значение переменной
step - пошаговое выполнение программы
watch - установить контрольное выражение, при изменении значения которого программа будет остановлена
9. 
* Выполнил компиляцию программы.
* Увидел ошибки в программе.
* Открыл редактор и исправил программу.
* Загрузил программу в отладчик *gdb*.
* run — отладчик выполнил программу, ввела требуемые значения. 
*   Использовал другие команды отладчика и проверил работу программы.
10.  Отладчику не понравился формат %s для &Operation, т.к %s — символьный формат, а значит необходим только Operation.
11.  Если вы работаете с исходным кодом, который не вами разрабатывался, то назначение различных конструкций может быть не совсем понятным. Система разработки приложений UNIX предоставляет различные средства, повышающие понимание исходного кода. К ним относятся:
* cscope - исследование функций, содержащихся в программе;
* splint — критическая проверка программ, написанных на языке Си.
12. 
* Проверка корректности задания аргументов всех использованных в программе функций, а также типов возвращаемых ими значений;
* Поиск фрагментов исходного текста, корректных с точки зрения синтаксиса языка Си, но малоэффективных с точки зрения их реализации или содержащих в себе семантические ошибки;
* Общая оценка мобильности пользовательской программы.
